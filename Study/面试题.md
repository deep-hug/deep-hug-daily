## CSS篇

### less和sass的区别是什么？
less是一门css预处理语言，它拓展了css语言。增加了嵌套，变量，Mixin，函数等特性，使css预压易维护和拓展。
sass支持了函数，对象，列表，判断，循环和@extend等，比less提供了更多的功能。

### link和@import 的区别
1、老祖宗的区别。link是XHTML的标签；import完全是css提供的一种方式。
2、加载顺序的区别。当一个页面被加载的时候，link引入的css会同时加载。Import引用的css会按需加载。
3、兼容性的区别。

### 什么是Event loop?
1、在执行主线程的任务时，如果有异步任务，会进入到Event Table中并注册回调函数，如果指定的任务结束后，会将这个回调函数放入到callback queue中。
2、主线程的任务结束后，会读取callback queue的回调函数放入到主线程执行。
3、一直重复这个循环操作，就是我们常说的event loop（时间循环）了。

### 宏任务是宿主发起的，微任务是JS引擎发起的。

### 怎么监听子组件的生命周期？
```js
    //  Parent.vue
    <Child @hook:mounted="doSomething" ></Child>

    doSomething() {
    console.log('父组件监听到 mounted 钩子函数 ...');
    },

    //  Child.vue
    mounted(){
    console.log('子组件触发 mounted 钩子函数 ...');
    },

    // 以上输出顺序为：
    // 子组件触发 mounted 钩子函数 ...
    // 父组件监听到 mounted 钩子函数 ...
```

### 页面渲染过程
1、根据html文件构建DOM树和CSSOM树。构建dom期间，如果遇到js，阻塞dom和cssom对的构建，优先构建完毕后，继续构建dom树和cssom树。
2、构建渲染树。
3、页面的重绘与重排。页面渲染完成后，若js操作了dom节点，根据js对dom树操作动作的大小，浏览器对页面进行重绘或者重排。

### 你了解模块加载机制吗？common js es6

#### 模块使用方式
common js ：require 关键字引入模块 module.exports 导出模块
es6 :  import 关键字引入模块 export.default 导出模块

#### 模块加载方式
common js : 运行时加载，一个模块就是一个对象，加载这个模块就是加载这个模块里面所有的方法，使用的时候只取所需要的方法
es6 : 编译时加载，在模块编译时就完成加载，引用的时候只加载所需要的方法，不需要的方法不加载。


### 什么是diff算法

diff算法就是进行虚拟节点的对比，然后返回一个patch对象，用来记录两个节点不同的地方，最后调用patch记录的信息去局部跟新dom

### module.exports 和 exports 的区别是什么？

说到 module.exports 和 exports 不得不说一下 require 关键字。我们都知道 node js 遵循 common js规范，使用 require 引入模块。

require 引入的模块加载是同步的。
1、一个作为公共依赖的模块，想要一次性加载出来，同步是最好的选择。
2、模块的个数往往是有限的，node 在 require 的时候会自动缓存已经加载过的模块，再加上访问的都是本地的文件，产生的IO开销可以忽略不计。

exports = module.exports = {}

### webpack是用来干嘛的

1、webpack只能打包js 文件，但是需要其他文件 例如：vue，css，img。需要安装特定的 loader；
2、loader 就是用来专门打包特定文件的处理程序；
3、webpack 就是一个打包工具，可以将多个js文件打包成一个js文件，这样做的好处就是可以减少http请求，提交页面相应效率。

### 什么是 webpack ？

概念：webpack是前端项目工程化的具体解决方案。

主要功能：它提供了友好的前端模块化开发支持，以及代码混淆、处理浏览器JavaScript的兼容性、性能优化等强大功能。
好处：让程序员把工作的重心放到具体功能的实现上面，提高了前端开发效率和项目的可维护性。

### 什么是前端工程化？

在企业级的前端开发中，将前端开发者所需要的工具，技术，流程，经验等进行规范化，标准化。并落实到细节上，就是前端开发者说的的四个“现代化”。（模块化，组件化，规划化，自动化）

### 前端工程化的好处是什么？

1、前端工程化让前端开发“自成体系”，覆盖了从项目创建到构建的方方面面；
2、最大程度上提高了前端的开发效率，降低了技术选型，前后端联调带来的协调沟通成本。


### webpack的打包流程。
1、初始化参数。从shell或者配置文件中读取参数。
2、编译。创建 compiler 独享，加载所有的插件，调用 compiler.run() 
3、确定入口。通过 entry 找到入口文件。
4、编译模块。递归所有依赖的模块，形成关系树。通过loader进行编译转换成最终js文件。
5、输入文件，根本依赖关系树，将模块依次输出到模块中。


### 有哪些常用plugin
1. define plugin 
2. commons chunk plugin 
3. uglyfyjs webpack plugin 
4. vue loader plugin 
5. hot moudule plugin 
6. html webpack plugin 
7. clean webpack plguin 
8. copy wepback plugin 
9. mini css extract plugin 
10. optimize css assets webpack plugin 
11. optimiztion chunk plugin 
12. @babel/plugin syntax dynamic import 
13. terser webpack plugin 

### 什么是闭包？
闭包是指有权访问另一个函数作用域中的变量的函数。
好处：防止全局变量污染。局部变量并没有被销毁，驻留在内存中，依然还可以访问到。
坏处：使用不当会造成内存泄漏。

#### 用途：
1、模仿块级作用域
2、保护外部函数的变量
3、封装私有化变量
4、创建模块

### 作用域 和 作用域链？

作用域： 简单来说就是 变量和函数的可访问范围。

全局作用域： 代码在程序的任何地方都能被访问。window对象的内置属性都拥有全局作用域。
函数作用域： 在固定的代码片段才能被访问。

### 什么是虚拟列表？

虚拟列表的核心就是可视化区域渲染。在页面的滚动的时候去截取数据，复用dom进行展示的渲染方式。

1、计算当前可视区域其实

### 使用eslint统一团队开发标准

分号；结尾。引号。var报警告。空格缩进。格式化html和js代码。

### 基于webpack-dev-server集成本地mock服务，提升开发联调效率。

webpack-dev-server 边修改边编译。

### TRTC 和 websocket 实现实时音视频问诊功能。

模块，组件，规范，自动化。


#### state 和 mapState 的使用

```js
    // 写在 computed 里面
    users () {
      return this.$store.state.users
    }

    ...mapState(['users'])

    products () {
      return this.$store.state.products.all
    }

    ...mapState('products',[
        'all',
    ])
```

#### getter 和 mapGetters 的使用

```js
    // 写在 computed 里面
    products () {
      return this.$store.getters['cart/cartProducts']
    }

    ...mapGetters('cart', ['cartProducts'])
```

### mutations 和 mapMutations 的使用
```js
    // 写在 computed 里面
    this.$store.commit('setSearch', {
        page
    })
    ...mapMutations([
        'add', // 将 `this.add()` 映射为 `this.$store.commit('add')`
    ])
    // 在 组件中进行这样调用
    this.add(1)
    // 将被映射为如下调用
    this.$store.commit('add', 1)



    this.$store.commit('bridge/setSearch', {
        page
    })
    ...mapMutations('bridge', [
        'setZHJCTJJG'
    ])
```

#### actions 和 mapActions 的使用
```js
    // 写在 computed 里面
    this.$store.dispatch('getNewNum')
    ...mapActions({
        add: 'getNewNum' // 将 `this.add()` 映射为 `this.$store.dispatch('getNewNum')`
    })
    // 在 组件中进行这样调用
    this.add(1)
    // 将被映射为如下调用
    this.$store.dispatch('getNewNum', 1)


    this.$store.dispatch('cart/addProductToCart', product)
    ...mapActions('cart', ['addProductToCart']),
```

```js
    this.$store.state.book.user
    ...mapState('book', ['user'])

    this.$store.getters['book/username']
    ...mapGetters('book', ['username'])

    this.$store.commit('book/setuser'. {})
    ...mapMutations('book', ['setuser'])
    
    this.$store.dispatch('book/getuser'. {})
    ...mapActions('book', ['getuser'])
```

### 递归
```js
function deepClone(obj) {
    let result = typeof  obj.splice === "function" ? [] : {};
    if (obj && typeof obj === 'object') {
        for (let key in obj) {
            if (obj[key] && typeof obj[key] === 'object') {
                result[key] = deepClone(obj[key]);//如果对象的属性值为object的时候，递归调用deepClone,即在吧某个值对象复制一份到新的对象的对应值中。
            } else {
                result[key] = obj[key];//如果对象的属性值不为object的时候，直接复制参数对象的每一个键值到新的对象对应的键值对中。
            }

        }
        return result;
    }
return obj;
}
```


### vuex是什么
1、vuex是一个专门为vue.js应用程序开发的“状态管理模式+库”。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。


### vuex怎么实现数据响应式的
利用vue.js的细粒度数据相应机制来进行高效的数据更新。


### 设计模式有哪些？
工厂、单例、原型、适配器、代理、迭代器、策略、订阅者、命令、状态

